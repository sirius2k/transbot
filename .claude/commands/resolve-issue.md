# GitHub 이슈 해결하기

너는 지금부터 GitHub Issue를 해결하는 엘리트 소프트웨어 개발자야. 인수(Argument)로 깃허브 이슈 고유 숫자를 넘겨주면 이 숫자에 해당되는 GitHub Issue를 해결하는 작업을 한다.

## 작업 순서

### 1. FEATURE 진행현황 업데이트

feature-execution-plan 폴더에서 이 이슈와 관련있는 FEATURE-XXX.md 파일내의 진행 현황 섹션의 정보를 업데이트 한다.

### 2. 이슈 불러오기

GitHub CLI를 사용해서 이슈를 불러와줘. 제목과, 본문, 레이블을 확인하고 이슈를 정확히 이해한다.

### 3. 브랜치 세팅하기

이슈를 해결할 브랜치를 세팅한다. main 브랜치에서 issue-$ISSUE_NUMBER 형태로 새로운 브랜치를 생성 후 작업한다. (예: issue-72)

### 4. FEATURE 문서 확인 ⭐ (Smart Skip 핵심)

**목적**: 중복 분석 방지 및 토큰 최적화

이슈와 연관된 FEATURE-XXX.md 파일을 읽고 "분석 수준" 메타데이터를 확인한다.

```markdown
## 개요
- **분석 수준**: 완료 / 부분 / 없음
```

#### 분석 수준별 다음 단계 전략

| 분석 수준 | FEATURE 문서 포함 내용 | 다음 단계 전략 | 예상 시간 | 토큰 사용 | 서브에이전트 |
| --------- | ---------------------- | ------------- | --------- | --------- | ------------ |
| **완료** | 아키텍처 설계 + 상세 코드 예시 + 테스트 계획 | 검증만 수행 | ~5분 | ~10k | 1개 |
| **부분** | Task 분해 + 기본 요구사항 + 간단한 예시 | 최소 분석 | ~15분 | ~15k | 2-3개 |
| **없음** | Task 분해만 | 전체 분석 | ~30분 | ~30k | 최대 10개 |

**토큰 절약 효과**:

- 완료: 80% 절약 (50k → 10k)
- 부분: 62% 절약 (40k → 15k)
- 없음: 0% 절약 (전체 분석 필요)

### 5. 코드베이스 분석하기 (조건부 실행)

**분석 수준이 "완료"인 경우**:

- FEATURE 문서의 아키텍처 설계 섹션 활용
- 검증 목적으로만 최소한의 코드베이스 탐색 (1개 서브에이전트)
- 확인 사항:
  - FEATURE 문서의 설계가 현재 코드베이스와 일치하는가?
  - 참조된 파일/클래스/함수가 존재하는가?
  - 새로 추가할 컴포넌트의 위치가 적절한가?

**분석 수준이 "부분"인 경우**:

- FEATURE 문서에서 누락된 부분만 분석 (2-3개 서브에이전트)
- 확인 사항:
  - 기존 패턴 및 컨벤션
  - 재사용 가능한 컴포넌트
  - 간단한 예시로 부족한 구현 세부사항

**분석 수준이 "없음"인 경우**:

- 전체 코드베이스 분석 (최대 10개 서브에이전트)
- 배정된 이슈를 해결하기 위해서 알고 있어야 하는 정보를 코드베이스 분석을 통해서 콘텍스트를 확보한다.
- 필요한만큼 서브에이전트를 생성해서 독립적으로 코드베이스를 리서치하도록 한다.

### 6. 이슈 해결 계획 세우기 (조건부 실행)

**분석 수준이 "완료"인 경우**:

- FEATURE 문서의 아키텍처 설계 + 코드 예시를 기반으로 즉시 구현 계획 수립
- Scratchpad에 간단한 체크리스트 작성
- 시간: ~2분

**분석 수준이 "부분" 또는 "없음"인 경우**:

- 취합한 정보를 기반으로 어떻게 이슈를 해결할지 상세 계획 수립
- Scratchpad를 사용해서 생각의 흐름을 모두 보여줘
- 시간: ~10-15분

### 7. 이슈 해결하기

계획을 기반으로 이슈를 해결한다. 하나의 서브에이전트를 생성해서 작업한다.

**분석 수준이 "완료"인 경우**:

- FEATURE 문서의 코드 예시를 참조하여 구현
- 설계 검증은 이미 완료되었으므로 코딩에만 집중

**분석 수준이 "부분" 또는 "없음"인 경우**:

- 수립한 계획에 따라 구현
- 필요시 추가 리서치 수행

### 8. 테스트 작성하기

작업한 이슈들을 검증 할 수 있는 유닛 테스트를 작성한다. 엣지 케이스들을 포함해서 80% 이상의 커버리지를 확보할 수 있는 테스트를 작성한다. 파일별로 독립적인 에이전트를 생성해서 병렬로 작업한다.

**분석 수준이 "완료"인 경우**:

- FEATURE 문서의 "테스트 계획" 섹션 참조
- 테스트 케이스 및 예시 코드 활용

**분석 수준이 "부분" 또는 "없음"인 경우**:

- 구현한 코드를 기반으로 테스트 케이스 설계 및 작성

### 9. 검증하기

테스트, 린트, 빌드를 각각 독립적인 서브에이전트로 실행하고 문제있는 이슈들을 해결한다.

### 10. FEATURE 문서 업데이트

feature-execution-plan에서 이 이슈와 관련있는 FEATURE-XXX.md 파일에 작업한 내용을 모두 업데이트 한다.

**업데이트 사항**:

- 진행 현황 테이블 (Task 상태, 실제 시간)
- 구현 완료 후 발견된 이슈나 개선사항
- 테스트 결과

### 11. PR 생성하기

Pull Request를 생성한다.

## 작업 시간 추적

- 실제 작업 시간을 현실적으로 측정하고 기록하여 프로젝트 관리의 정확성을 높인다.
- `docs/feature-execution-log/WORKLOG-FEATURE-SAMPLE.log` 파일을 참고하여 작업 시간 기록 규칙을 따라 작업 시간을 기록한다. 해당 파일이 없으면 작업 시간을 기록하지 않는다.

### 로그 파일 위치

- **파일 경로**: `docs/feature-execution-log/WORKLOG-FEATURE-XXX.log`
- **예시**: `docs/feature-execution-log/WORKLOG-FEATURE-000.log`
- **디렉토리 생성**: `docs/feature-execution-log/` 디렉토리가 없으면 자동 생성

### 시간 기록 규칙

1. **각 단계 시작 시**: 로그 파일에 시작 시간 기록
2. **각 단계 완료 시**: 로그 파일에 완료 시간 및 소요 시간 기록
3. **모든 작업 완료 시**: 유형별 합산 및 총 작업 시간 계산하여 요약 섹션 업데이트
4. **FEATURE-XXX.md 업데이트 시**: 로그 파일의 "총 작업 시간"을 참조하여 실제 시간 입력

### FEATURE 문서 연동

FEATURE-XXX.md의 진행 현황 테이블 업데이트 시:
- **실제 시간** 컬럼: `docs/feature-execution-log/FEATURE-XXX-TASK-YY.log` 파일의 "총 작업 시간" 참조
- 로그 파일이 없으면 대략적인 시간 기록 후 로그 생성 권장
